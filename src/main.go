package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"time"
	"unsafe"

	"Famicom-emulator/cpu"

	"github.com/veandco/go-sdl2/sdl"
)

func main() {
	fmt.Println("Hello, world!")
	runCPUTestGame()
}

func createWindow(c *cpu.CPU) {
	// SDL2の初期化
	if err := sdl.Init(sdl.INIT_VIDEO); err != nil {
		log.Fatalf("Failed to initialize SDL: %s", err)
	}
	defer sdl.Quit()

	rand.Seed(time.Now().UnixNano())
	scaleFactor := 10.0

	// ウィンドウの作成（中央配置）
	window, err := sdl.CreateWindow(
		"Famicom emulator",
		sdl.WINDOWPOS_CENTERED,
		sdl.WINDOWPOS_CENTERED,
		int32(32 * scaleFactor),
		int32(32 * scaleFactor),
		sdl.WINDOW_SHOWN,
	)
	if err != nil {
		log.Fatalf("Failed to create window: %s", err)
	}
	defer window.Destroy()

	// レンダラーの作成（VSyncあり）
	renderer, err := sdl.CreateRenderer(
		window,
		-1,
		sdl.RENDERER_ACCELERATED|sdl.RENDERER_PRESENTVSYNC,
	)
	if err != nil {
		log.Fatalf("Failed to create renderer: %s", err)
	}
	defer renderer.Destroy()

	// レンダラーのスケール設定
	if err := renderer.SetScale(float32(scaleFactor), float32(scaleFactor)); err != nil {
		log.Fatalf("Failed to set scale: %s", err)
	}

	// テクスチャの作成
	texture, err := renderer.CreateTexture(
		sdl.PIXELFORMAT_RGB24,
		sdl.TEXTUREACCESS_STREAMING,
		32, 32,
	)
	if err != nil {
		log.Fatalf("Failed to create texture: %s", err)
	}
	defer texture.Destroy()

	// 画面状態配列を初期化
	var screenState [32 * 3 * 32]uint8
	for i := range screenState {
		screenState[i] = 0
	}

	running := true

	// メインループ
	c.Run(func(c *cpu.CPU) {
		// イベント処理
		for event := sdl.PollEvent(); event != nil; event = sdl.PollEvent() {
			switch e := event.(type) {
			case *sdl.QuitEvent:
				running = false
			case *sdl.KeyboardEvent:
				if e.Keysym.Sym == sdl.K_ESCAPE && e.State == sdl.PRESSED {
					running = false
				}

				// キー入力の処理（押された時のみ）
				if e.State == sdl.PRESSED {
					switch e.Keysym.Sym {
					case sdl.K_w:
						c.WriteByteToWRAM(0xFF, 0x77)
					case sdl.K_s:
						c.WriteByteToWRAM(0xFF, 0x73)
					case sdl.K_a:
						c.WriteByteToWRAM(0xFF, 0x61)
					case sdl.K_d:
						c.WriteByteToWRAM(0xFF, 0x64)
					default:
					}
				}
			}
		}

		// 0xFEに乱数を書き込み（1-15の範囲）
		c.WriteByteToWRAM(0xFE, uint8(rand.Intn(15)+1))

		// 画面状態の更新をチェックし、変更があれば描画
		if readScreenState(c, &screenState) {
			// テクスチャを更新
			texture.Update(nil, unsafe.Pointer(&screenState), 32*3)

			// レンダラーをクリア
			renderer.Clear()

			// テクスチャをレンダラーにコピー
			renderer.Copy(texture, nil, nil)

			// 画面に表示
			renderer.Present()
		}

		// CPUのフレームレート調整
		time.Sleep(70 * time.Microsecond)

		// 終了条件をチェック
		if !running {
			sdl.Quit()
			os.Exit(0)
		}
	})
}

func readScreenState(c *cpu.CPU, frame *[32 * 3 * 32]uint8) bool {
	frameIdx := 0
	update := false
	for i := 0x0200; i < 0x0600; i++ {
		colorIdx := c.ReadByteFromWRAM(uint16(i))
		col := color(colorIdx)
		if frame[frameIdx] != col.R || frame[frameIdx+1] != col.G || frame[frameIdx+2] != col.B {
			frame[frameIdx] = col.R
			frame[frameIdx+1] = col.G
			frame[frameIdx+2] = col.B
			update = true
		}

		frameIdx += 3
	}

	return update
}

func color(bytes uint8) sdl.Color {
	switch bytes {
	case 0:
		return sdl.Color{R: 0, G: 0, B: 0, A: 255} // BLACK
	case 1:
		return sdl.Color{R: 255, G: 255, B: 255, A: 255} // WHITE
	case 2, 9:
		return sdl.Color{R: 128, G: 128, B: 128, A: 255} // GREY
	case 3, 10:
		return sdl.Color{R: 255, G: 0, B: 0, A: 255} // RED
	case 4, 11:
		return sdl.Color{R: 0, G: 255, B: 0, A: 255} // GREEN
	case 5, 12:
		return sdl.Color{R: 0, G: 0, B: 255, A: 255} // BLUE
	case 6, 13:
		return sdl.Color{R: 255, G: 0, B: 255, A: 255} // MAGENTA
	case 7, 14:
		return sdl.Color{R: 255, G: 255, B: 0, A: 255} // YELLOW
	default:
		return sdl.Color{R: 0, G: 255, B: 255, A: 255} // CYAN
	}
}

// デバッグ用スネークゲーム
func runCPUTestGame() {
	var baseAddr uint16 = 0x0600
	var GAME = [309]uint8{
		0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe, 0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60, 0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06, 0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c, 0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9, 0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6, 0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60, 0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
	}

	c := cpu.CreateCPU(true)

	// スネークゲームは$0600 ~ をゲームデータとして使う
	for _, data := range GAME {
		c.WriteByteToWRAM(baseAddr, data)
		baseAddr++
	}

	// CPUは0xFFFCからの1wordをPCの初期値とする
	c.WriteWordToWRAM(0xFFFC, 0x0600)
	c.Init(true)

	// ウィンドウとレンダラーを準備
	createWindow(c)
}